<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>


  <script>

    // ⭐ prototype은
    // (1) constructor 함수에만 몰래 생성된다. (어레이나 오브젝트에 .찍고 prototype 해도 안나옴)
    function 기계(파라미터, 파라미터2) {
      this.name = 파라미터;
      this.age = 파라미터2;
      this.sayHi = function () {
        console.log('저의 이름은' + this.name + '입니다.');
      }
    }

    기계.prototype.gender = '남';
    console.log(기계.prototype.gender);

    var 학생1 = new 기계('손흥민', 20);

    console.log(학생1.__proto__); // (2) 모든 자식들은 유전자(prototype)를 검사할 수 있다.
    //  - 내 부모 유전자(부모의 prototype)를 검사하고 싶으면 __proto__ 사용
    // 즉, __proto__는 부모의 prototype과 같은 의미이며, 내 부모 유전자가 뭔지 검사하고싶을때 사용하는 값이라고 생각하면 된다.
    console.log(기계.prototype);
    // 학생1.__proto__과 기계.prototype 을 각각 출력해보면 똑같은게 나온다.


    // (3) __proto__를 직접 등록하면 object끼리 상속기능을 구현가능
    var 부모 = { name: 'Kim' };
    var 자식 = {};

    자식.__proto__ = 부모;  // 자식 오브젝트의 __proto__에 부모를 집어넣으면
    // 자식의 부모 프로토타입은 { name : 'kim'}이라는 오브젝트가 되는 것
    // 그렇게 되면 자식은 이제 자식.name 을 사용할 수 있게됨
    console.log(자식.name);


    // (4) 콘솔창에 prototype 정보들이 항상 출력된다.
    // function 기계() {
    //   this.name = 'Kim';
    //   this.age = 15;
    // }
    // 기계.prototype.gender = '남';

    // var 학생1 = new 기계();
    // 학생1을 콘솔창에 출력해서 __proto__를 통해 부모의 부모까지 탐색할 수 있음
    // 탐색해보면 모든 object 자료형의 조상은 Object() 라는 기계이며 (일명 Object.prototype)
    // 모든 array 자료형의 조상도 Object()이다. (중간에 Array()라는 부모도 있음)
    // 모든 함수 자료형의 조상도 Object() 임 (그래서 자바스크립트는 모든게 다 Object라고 말하는 것)

  </script>


</body>

</html>