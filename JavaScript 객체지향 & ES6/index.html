<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>


  <script>

    // ⭐ ES6 방식으로 상속기능 구현하기  (class)

    // class 문법은
    // 기존 function부터 시작하던 문법과 기능상 차이는 크게 없고, 약간 더 보기쉽게 표현해줄 뿐이다.

    // ⭐ class 키워드로 constructor 만들기
    class 부모 {
      constructor(파라미터){
        this.name = 파라미터;
        // ✅ 함수를 추가하고 싶을때
        // (1) constructor 안에 추가하던가 (여기에 추가하면 자식이 직접 함수를 가짐)
        // this.sayHi = function(){ console.log('hello')}
      }
      // (2) constructor 바깥인 여기에 쓰던가
      // 근데 여기에 쓰면 부모.prototype에 추가됨
      sayHi() {
        console.log('hello')
      }
      // ✅ 함수를 여러개 추가하고 싶으면?
      // (1) 나란히 쓰거나
      // sayHi2() {
      //   console.log('hello2')
      // }
    }
    // (2) 부모 prototype을 이용해서 함수 만들면됨
    부모.prototype.sayHi2 = function(){ console.log('hello2')}


    var 자식 = new 부모('파라미터');    // 자식 오브젝트 만들기

    // 참고
    // 자식.__proto__;  // 부모의 prototype이 출력됨
    // Object.getPrototypeOf(자식);  // 부모 prototype이 출력
    // 둘이 같은 의미임


    // 객체지향 문법은 왜쓸까?
    // 이유 (1). object 여러개를 만들어 쓰기 위해 사용하는 것!
    // 

  </script>


</body>

</html>