<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>


  <script>

    // ⭐ 상속을 구현할 수 있는 또 다른 문법 prototype

    function 기계2(파라미터, 파라미터2) {
      this.name = 파라미터;
      this.age = 파라미터2;
      this.sayHi = function () {
        console.log('저의 이름은' + this.name + '입니다.');
      }
    }

    var 학생3 = new 기계2('손흥민', 20);  // 기계라는 constructor가 가진 name, age 속성들을 그대로 물려받아서 오브젝트를 하나 뽑아주는것을 상속이라고 부릅니다.
    // 뭐 재산 물려주는 상속과 비슷하다고 해서 상속이라고 부릅니다. 
    // (그래서 상속해주는 것(기계2)은 부모, 상속받는 오브젝트들(학생3)은 자식이라고 많이 비유해서 불러요)

    // 근데 자바스크립트엔 constructor 말고도 상속기능을 구현할 수 있는 장치가 하나 더 있는데
    // 그것이 바로 prototype
    // 위의 기계2 함수는 prototype이라는 항목을 내부에 몰래 생성함
    console.log(기계2.prototype);
    // 프로토타입이라는 비밀공간은 부모의 유전자역할을 해주는 일종의 비밀공간이라고 보면된다.
    // 쉽게 말해 프로토타입은 자식들이 부모로부터 물려받을 수 있는 유전자라고 생각하면된다.
    // 기계2.prototype은 기계2의 유전자이다.
    // 기계2.prototype 에 뭔가 변수나 함수가 들어가있다면 기계2로부터 생성되는 새로운 오브젝트들(자식들)은 전부 그걸 그대로 물려받아 쓸 수 있습니다.

    기계2.prototype.gender = '남'; // 기계2의 prototype, 즉 유전자에 gender : '남'이라는 데이터를 추가한 것
    // 이제 학생1, 학생3 같은 기계2로부터 생성되는 모든 자식들은 gender라는 속성을 사용할 수 있다.



    /* (참고)
- prototype에는 값을 여러개 부여할 수도 있고 심지어 함수도 집어넣으실 수 있습니다. object 자료처럼 다뤄주시면 됩니다. 
- prototype에 추가된 데이터들은 자식들이 직접 가지는게 아니라 부모만 가지고 있습니다.
    */

/*
⭐ 학생3.gender라고 사용하면 '남'이 출력되죠? 그 이유는..
자바스크립트는 오브젝트에서 값을 출력할 때 이런 순서로 물어봅니다.
(1) 학생1에 직접 gender라는 값이 있는가?
(2) 그럼 부모 유전자에 gender라는 값이 있는가?
(3) 그럼 부모의 부모 유전자에 gender라는 값이 있는가?
(4) 그럼 부모의 부모의 부모의 유전자에 .. 그게 있는가?

쉽게말하자면 오브젝트에서 값을 뽑을 때 
1. 내가 직접 가지고 있는지 검사
2. 내가 가지고 있지 않으면 부모 유전자들을 차례로 검사하는구나
라고 잘 기억해주시면 됩니다. 

그래서 학생3이라는 오브젝트가 gender라는 값을 가지고 있지 않지만
부모의 유전자(기계2.prototype) 에 있는 gender라는 걸 출력할 수 있는 이유입니다. 
*/


// ⭐ 자바스크립트 내장함수 toString() 을 쓸 수 있는 이유
var arr = [1,2,3];
console.log( arr.toString() ); //가능

// 내가 만든 array에 arr.toString() 이렇게 붙일 수 있는 이유는 
// 내가 만든 array의 부모 유전자가 toString()을 가지고 있기 때문입니다. (혹은 부모의 부모요)

/*
var arr = [1,2,3];
var arr = new Array(1,2,3);
▲ 위 코드 두줄은 같은 완전 똑같은 의미입니다.
위는 인간이 array 만드는 방식, 밑은 컴퓨터가 array 만드는 방식입니다. 
사람은 귀찮아서 [] 그냥 대괄호쳐서 만드는데 내부적으로는 저렇게 new 키워드를 항상 이용해서 array/object를 만들어줍니다.  

그럼 new Array() 이게 뭔뜻이죠?
Array라는 기계로부터 자식을 하나 새로 뽑아주세요 라는 뜻 아닌가요?
맞습니다. 

그래서 Array로부터 생성된 자식들은 Array의 유전자에 부여되어있는 함수, 데이터들을 자유롭게 사용하실 수 있습니다. 
Array라는 기계의 유전자가 진짜 있는지 확인은 콘솔창에 출력해보시면 됩니다. 
console.log(Array.prototype);
이렇게 하면 뭐나옵니까. 여러분이 평소에 쓰던 sort, map, push, forEach 이런 것들이 등장합니다. 
그래서 Array의 자식들은 전부 이런 함수들을 쉽게 가져다 쓸 수 있었던 것입니다. 

Object 자료형도 똑같이 new Object() 이런 식으로 만들어주기 때문에 부모의 prototype에 있던 함수들을 자유롭게 사용가능합니다. 
이것이 내장함수들의 비밀이었습니다.


Q. 그럼 prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이가 뭐죠?

A. 자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고
부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 되겠쥬?
보통은 그래서 상속할 수 있는 함수 같은 것들은 prototype으로 많이 만들어놓습니다. 

*/


  </script>


</body>

</html>