<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  html,
  body {
    margin: 0;
    height: 100%;
  }

  #c {
    width: 100%;
    height: 100%;
    display: block;
  }

  #container {
    position: relative;
    /* 자식이 이 요소를 기준 삼도록 합니다. */
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  #labels {
    position: absolute;
    /* 캔버스 위에 자리잡도록 합니다. */
    left: 0;
    /* id=container 위 왼쪽에 기준하도록 합니다. */
    top: 0;
    color: white;
    z-index: 0;
  }

  /* 이름표의 CSS 작성 */
  #labels>div {
    position: absolute;
    /* 캔버스 위에 자리잡도록 합니다.  */
    left: 0;
    /* 부모의 위 왼쪽에 기준하도록 합니다. */
    top: 0;
    cursor: pointer;
    /* 포인터가 위에 올라갔을 때 포인터 스타일을 바꿉니다. */
    font-size: small;
    user-select: none;
    /* 텍스트를 선택할 수 없도록 합니다. */
    text-shadow:
      /* 글자에 검은 테두리를 두릅니다. */
      -1px -1px 0 #000,
      0 -1px 0 #000,
      1px -1px 0 #000,
      1px 0 0 #000,
      1px 1px 0 #000,
      0 1px 0 #000,
      -1px 1px 0 #000,
      -1px 0 0 #000;
    pointer-events: none;
  }

  #labels>div:hover {
    color: red;
  }
</style>

<body>
  <!-- 이름표를 담을 HTML 요소 추가하기 -->
  <div id="container">
    <canvas id="c"></canvas>
    <div id="labels"></div>
  </div>

  <script type="importmap">{
    "imports": {
      "three": "https://threejs.org/build/three.module.js",
      "three/addons/": "https://threejs.org/examples/jsm/"
    }
  }</script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    function main() {
      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({ canvas });

      // 카메라 설정
      const fov = 60;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      const far = 10;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.z = 2.5;

      // 마우스 컨트롤 (드래그, 줌 등)
      const controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.minDistance = 1.2;
      controls.maxDistance = 4;
      controls.update();

      // 장면
      const scene = new THREE.Scene();
      scene.background = new THREE.Color('#246'); // 씬의 배경

      const pickingScene = new THREE.Scene();
      pickingScene.background = new THREE.Color(0);

      // 팔레트를 조작해 선택한 나라의 색상만 바꾸도록
      // Three.js의 Color를 매개변수로 받아 팔레트 텍스처에 지정할 수 있는 값을 반환
      const tempColor = new THREE.Color();
      // color = get255BasedColor('red')와 같은 식으로 호출하면 [255, 0, 0] 이런 식의 배열을 반환한다.
      function get255BasedColor(color) {
        tempColor.set(color);
        const base = tempColor.toArray().map(v => v * 255);
        base.push(255); // alpha
        return base;
      }

      // 아래는 팔레트 텍스처를 만드는 코드
      const maxNumCountries = 512;  // 512 RGBA 색상
      const paletteTextureWidth = maxNumCountries;
      const paletteTextureHeight = 1;
      const palette = new Uint8Array(paletteTextureWidth * 4);
      const paletteTexture = new THREE.DataTexture(palette, paletteTextureWidth, paletteTextureHeight);
      paletteTexture.minFilter = THREE.NearestFilter;
      paletteTexture.magFilter = THREE.NearestFilter;

      const selectedColor = get255BasedColor('red');
      const unselectedColor = get255BasedColor('#444');
      const oceanColor = get255BasedColor('rgb(100,200,255)');
      resetPalette();

      function setPaletteColor(index, color) {
        palette.set(color, index * 4);
      }

      function resetPalette() {
        // 모든 팔레트의 색상을 unselectedColor로 바꿉니다.
        for (let i = 1; i < maxNumCountries; ++i) {
          setPaletteColor(i, unselectedColor);
        }

        // 바다의 색을 지정합니다. (index #0)
        setPaletteColor(0, oceanColor);
        paletteTexture.needsUpdate = true;
      }

      {
        const loader = new THREE.TextureLoader();
        const geometry = new THREE.SphereGeometry(1, 64, 32);

        const indexTexture = loader.load('https://threejs.org/manual/examples/resources/data/world/country-index-texture.png', render);
        indexTexture.minFilter = THREE.NearestFilter;
        indexTexture.magFilter = THREE.NearestFilter;

        const pickingMaterial = new THREE.MeshBasicMaterial({ map: indexTexture });
        pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

        const fragmentShaderReplacements = [
          {
            from: '#include <common>',
            to: `
          #include <common>
          uniform sampler2D indexTexture;
          uniform sampler2D paletteTexture;
          uniform float paletteTextureWidth;
        `,
          },
          {
            from: '#include <color_fragment>',
            to: `
          #include <color_fragment>
          {
            vec4 indexColor = texture2D(indexTexture, vUv);
            float index = indexColor.r * 255.0 + indexColor.g * 255.0 * 256.0;
            vec2 paletteUV = vec2((index + 0.5) / paletteTextureWidth, 0.5);
            vec4 paletteColor = texture2D(paletteTexture, paletteUV);
            // diffuseColor.rgb += paletteColor.rgb;   // white outlines
            diffuseColor.rgb = paletteColor.rgb - diffuseColor.rgb;  // black outlines
          }
        `,
          },
        ];

        const texture = loader.load('https://threejs.org/manual/examples/resources/data/world/country-outlines-4k.png', render);
        const material = new THREE.MeshBasicMaterial({ map: texture });
        material.onBeforeCompile = function (shader) {
          fragmentShaderReplacements.forEach((rep) => {
            shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
          });
          shader.uniforms.paletteTexture = { value: paletteTexture };
          shader.uniforms.indexTexture = { value: indexTexture };
          shader.uniforms.paletteTextureWidth = { value: paletteTextureWidth };
        };
        scene.add(new THREE.Mesh(geometry, material));
      }

      async function loadJSON(url) {
        const req = await fetch(url);
        return req.json();
      }

      let numCountriesSelected = 0;
      let countryInfos;
      async function loadCountryData() {
        countryInfos = await loadJSON('https://threejs.org/manual/examples/resources/data/world/country-info.json');

        // 씬 그래프를 활용해 지구본의 위도와 경도를 계산
        const lonFudge = Math.PI * 1.5;
        const latFudge = Math.PI;
        // 아래 헬퍼 Object3D는 육면체들의 위치 변화를 간단하게 만들어줍니다.
        const lonHelper = new THREE.Object3D(); // lonHelper를 Y축으로 돌려 경도(longitude)를 맞출 수 있습니다.
        const latHelper = new THREE.Object3D(); // latHelper를 X축으로 돌려 위도(latitude)를 맞출 수 있습니다.
        lonHelper.add(latHelper);
        // The position helper moves the object to the edge of the sphere
        const positionHelper = new THREE.Object3D();  // positionHelper는 다른 요소의 기준축을 구체의 끝에 맞추는 역할을 합니다.
        positionHelper.position.z = 1;
        latHelper.add(positionHelper);

        // 각 이름표의 좌표를 계산
        const labelParentElem = document.querySelector('#labels');
        for (const countryInfo of countryInfos) {
          const { lat, lon, min, max, name } = countryInfo;

          // 헬퍼가 위도와 경도를 가리키게 바꿉니다.
          lonHelper.rotation.y = THREE.MathUtils.degToRad(lon) + lonFudge;
          latHelper.rotation.x = THREE.MathUtils.degToRad(lat) + latFudge;

          // 위도와 경도를 구합니다.
          positionHelper.updateWorldMatrix(true, false);
          const position = new THREE.Vector3();
          positionHelper.getWorldPosition(position);
          countryInfo.position = position;

          
          const width = max[0] - min[0];
          const height = max[1] - min[1];
          const area = width * height;
          countryInfo.area = area;

          // 각 나라마다 텍스트 요소를 추가합니다.
          const elem = document.createElement('div');
          elem.textContent = name;
          labelParentElem.appendChild(elem);
          countryInfo.elem = elem;
        }
        requestRenderIfNotRequested();
      }
      loadCountryData();

      const tempV = new THREE.Vector3();
      const cameraToPoint = new THREE.Vector3();
      const cameraPosition = new THREE.Vector3();
      const normalMatrix = new THREE.Matrix3();

      const settings = {
        minArea: 20,
        maxVisibleDot: -0.2,
      };

      function updateLabels() {
        // 아직 데이터를 불러오지 않았을 경우
        if (!countryInfos) {
          return;
        }

        const large = settings.minArea * settings.minArea;
        normalMatrix.getNormalMatrix(camera.matrixWorldInverse);  // 카메라의 상대 방향을 나타내는 행렬 좌표를 가져온다.
        camera.getWorldPosition(cameraPosition);  // 카메라의 위치를 가져온다.
        for (const countryInfo of countryInfos) {
          const { position, elem, area, selected } = countryInfo;
          const largeEnough = area >= large;
          const show = selected || (numCountriesSelected === 0 && largeEnough);
          if (!show) {
            elem.style.display = 'none';
            continue;
          }

          // Orient the position based on the camera's orientation.
          // Since the sphere is at the origin and the sphere is a unit sphere
          // this gives us a camera relative direction vector for the position.
          tempV.copy(position);
          tempV.applyMatrix3(normalMatrix);

          // compute the direction to this position from the camera
          cameraToPoint.copy(position);
          cameraToPoint.applyMatrix4(camera.matrixWorldInverse).normalize();

          // get the dot product of camera relative direction to this position
          // on the globe with the direction from the camera to that point.
          // -1 = facing directly towards the camera
          // 0 = exactly on tangent of the sphere from the camera
          // > 0 = facing away
          const dot = tempV.dot(cameraToPoint);

          // if the orientation is not facing us hide it.
          if (dot > settings.maxVisibleDot) {
            elem.style.display = 'none';
            continue;
          }

          // restore the element to its default display style
          elem.style.display = '';

          // get the normalized screen coordinate of that position
          // x and y will be in the -1 to +1 range with x = -1 being
          // on the left and y = -1 being on the bottom
          tempV.copy(position);
          tempV.project(camera);

          // convert the normalized position to CSS coordinates
          const x = (tempV.x * .5 + .5) * canvas.clientWidth;
          const y = (tempV.y * -.5 + .5) * canvas.clientHeight;

          // move the elem to that position
          elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;

          // set the zIndex for sorting
          elem.style.zIndex = (-tempV.z * .5 + .5) * 100000 | 0;
        }
      }

      class GPUPickHelper {
        constructor() {
          // 1x1 픽셀 크기의 렌더 타겟을 생성합니다
          this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
          this.pixelBuffer = new Uint8Array(4);
        }
        pick(cssPosition, scene, camera) {
          const { pickingTexture, pixelBuffer } = this;

          // view offset을 마우스 포인터 아래 1픽셀로 설정합니다
          const pixelRatio = renderer.getPixelRatio();
          camera.setViewOffset(
            renderer.getContext().drawingBufferWidth,   // 전체 너비
            renderer.getContext().drawingBufferHeight,  // 전체 높이
            cssPosition.x * pixelRatio | 0,             // 사각 x 좌표
            cssPosition.y * pixelRatio | 0,             // 사각 y 좌표
            1,                                          // 사각 좌표 width
            1,                                          // 사각 좌표 height
          );
          // 장면을 렌더링 하는 부분
          renderer.setRenderTarget(pickingTexture);
          renderer.render(scene, camera);
          renderer.setRenderTarget(null);
          // view offset을 정상으로 돌려 원래의 화면을 렌더링하도록 한다.
          camera.clearViewOffset();
          // 픽셀을 감지한다.
          renderer.readRenderTargetPixels(
            pickingTexture,
            0,   // x
            0,   // y
            1,   // width
            1,   // height
            pixelBuffer);

          const id =
            (pixelBuffer[0] << 0) |
            (pixelBuffer[1] << 8) |
            (pixelBuffer[2] << 16);

          return id;
        }
      }

      // GPUPickHelper를 이용해 나라를 선택하도록 함
      const pickHelper = new GPUPickHelper();

      const maxClickTimeMs = 200;
      const maxMoveDeltaSq = 5 * 5;
      const startPosition = {};
      let startTimeMs;

      
      function getCanvasRelativePosition(event) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: (event.clientX - rect.left) * canvas.width / rect.width,
          y: (event.clientY - rect.top) * canvas.height / rect.height,
        };
      }

      function recordStartTimeAndPosition(event) {
        startTimeMs = performance.now();
        const pos = getCanvasRelativePosition(event);
        startPosition.x = pos.x;
        startPosition.y = pos.y;
      }

      function pickCountry(event) {
        // 아직 데이터를 불러오지 않았을 경우
        if (!countryInfos) {
          return;
        }

        // if it's been a moment since the user started
        // then assume it was a drag action, not a select action
        const clickTimeMs = performance.now() - startTimeMs;
        if (clickTimeMs > maxClickTimeMs) {
          return;
        }

        // if they moved assume it was a drag action
        const position = getCanvasRelativePosition(event);
        const moveDeltaSq = (startPosition.x - position.x) ** 2 +
          (startPosition.y - position.y) ** 2;
        if (moveDeltaSq > maxMoveDeltaSq) {
          return;
        }

        const id = pickHelper.pick(position, pickingScene, camera);
        if (id > 0) {
          const countryInfo = countryInfos[id - 1];
          const selected = !countryInfo.selected;
          // 나라를 클릭했을 때 특수키를 누르지 않았다면 다른 나라의 'selected' 속성을 전부 끈다.
          if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
            unselectAllCountries();
          }
          numCountriesSelected += selected ? 1 : -1;
          countryInfo.selected = selected;
          setPaletteColor(id, selected ? selectedColor : unselectedColor);
          paletteTexture.needsUpdate = true;
        } else if (numCountriesSelected) {
          // 바다나 하늘을 클릭했을 경우
          unselectAllCountries();
        }
        requestRenderIfNotRequested();
      }

      function unselectAllCountries() {
        numCountriesSelected = 0;
        countryInfos.forEach((countryInfo) => {
          countryInfo.selected = false;
        });
        // resetPalette 함수를 이용해 나라를 선택했을 때 팔레트를 업데이트
        resetPalette();
      }

      canvas.addEventListener('pointerdown', recordStartTimeAndPosition);
      canvas.addEventListener('pointerup', pickCountry);

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      let renderRequested = false;

      function render() {
        renderRequested = undefined;

        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        controls.update();

        updateLabels();

        renderer.render(scene, camera);
      }
      render();

      function requestRenderIfNotRequested() {
        if (!renderRequested) {
          renderRequested = true;
          requestAnimationFrame(render);
        }
      }

      controls.addEventListener('change', requestRenderIfNotRequested);
      window.addEventListener('resize', requestRenderIfNotRequested);
    }

    main();




  </script>
</body>

</html>