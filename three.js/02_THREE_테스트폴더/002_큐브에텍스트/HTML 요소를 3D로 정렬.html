<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  html,
  body {
    margin: 0;
    height: 100%;
  }

  #c {
    width: 100%;
    height: 100%;
    display: block;
  }

  #container {
    position: relative;
    /* 자식이 이 요소를 기준 삼도록 합니다. */
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  #labels {
    position: absolute;
    /* 캔버스 위에 자리잡도록 합니다. */
    left: 0;
    /* id=container 위 왼쪽에 기준하도록 합니다. */
    top: 0;
    color: white;
  }

  /* 이름표의 CSS 작성 */
  #labels>div {
    position: absolute;
    /* 캔버스 위에 자리잡도록 합니다.  */
    left: 0;
    /* 부모의 위 왼쪽에 기준하도록 합니다. */
    top: 0;
    cursor: pointer;
    /* 포인터가 위에 올라갔을 때 포인터 스타일을 바꿉니다. */
    font-size: large;
    user-select: none;
    /* 텍스트를 선택할 수 없도록 합니다. */
    text-shadow:
      /* 글자에 검은 테두리를 두릅니다. */
      -1px -1px 0 #000,
      0 -1px 0 #000,
      1px -1px 0 #000,
      1px 0 0 #000,
      1px 1px 0 #000,
      0 1px 0 #000,
      -1px 1px 0 #000,
      -1px 0 0 #000;
  }

  #labels>div:hover {
    color: red;
    opacity: 0.5;
  }
</style>

<body>
  <!-- 이름표를 담을 HTML 요소 추가하기 -->
  <div id="container">
    <canvas id="c"></canvas>
    <div id="labels"></div>
  </div>

  <script type="importmap">{
    "imports": {
      "three": "https://threejs.org/build/three.module.js",
      "three/addons/": "https://threejs.org/examples/jsm/"
    }
  }</script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';


    function main() {
      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({ canvas });

      // 카메라
      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      const far = 5;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.z = 3;

      // 마우스 드래그 및 줌
      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 0, 0);
      controls.update();

      // 장면
      const scene = new THREE.Scene();

      // 조명
      {
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(-1, 2, 4);
        scene.add(light);
      }

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);


      const labelContainerElem = document.querySelector('#labels');

      function makeInstance(geometry, color, x, name) {
        const material = new THREE.MeshPhongMaterial({ color });

        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        cube.position.x = x;

        // makeInstance라는 함수에서 정육면체를 만들때 이름표 요소를 같이 만들도록 바꾸기
        const elem = document.createElement('div');
        elem.textContent = name;
        labelContainerElem.appendChild(elem);

        return {cube, elem};
      }

      // 정육면체(cube)만 반환하는 게 아니라 이름표 요소(label)를 같이 반환하도록
      const cubes = [
        makeInstance(geometry, 0x44aa88, 0, '❌'),
        makeInstance(geometry, 0x8844aa, -2, 'purple'),
        makeInstance(geometry, 0xaa8844, 2, 'Gold'),
      ];

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = canvas.clientWidth * pixelRatio | 0;
        const height = canvas.clientHeight * pixelRatio | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      // 렌더링 시 이름표의 위치 정해주기
      const tempV = new THREE.Vector3();
      console.log(tempV)  // x, y, z값이 나옴
      // 이름표 위치에서 RayCaster로 광선을 쏴 처음으로 걸리는 물체가 이름표와 짝이 아니라면 이름표를 보이지 않게 하는 것
      const raycaster = new THREE.Raycaster();

      function render(time) {
        time *= 0.001;

        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        cubes.forEach((cubeInfo, ndx) => {
          const { cube, elem } = cubeInfo;
          const speed = 1 + ndx * .1;
          const rot = time * speed;
          // cube.rotation.x = rot;
          // cube.rotation.y = rot;

          // 정육면체의 중심 좌표 가져오기
          cube.updateWorldMatrix(true, false);
          cube.getWorldPosition(tempV);

          /**
          * 정규화(normalize)된 화면 상의 현재 좌표값을 가져옵니다.
          * x와 y의 범위는 -1에서 +1까지로, x = -1은 왼쪽, y = -1은 아래쪽입니다.
          **/
          tempV.project(camera);



          // 이름표 위치에서 RayCaster로 광선을 쏴 처음으로 걸리는 물체가 이름표와 짝이 아니라면 이름표를 보이지 않게 하기
          // raycaster로 이름표의 시점과 만나는 물체를 구합니다.
          raycaster.setFromCamera(tempV, camera);
          const intersectedObjects = raycaster.intersectObjects(scene.children);
          // 짝궁 정육면체가 제일 처음 보이는 물체와 같다면 이름표를 보이게 합니다.
          const show = intersectedObjects.length && cube === intersectedObjects[0].object;
        
          // if (!show) {
            // 절두체 밖으로 나갔을 경우의 문제를 해결하기 위해 tempY.z 값으로 정육면체의 중심이 절두체 밖으로 나갔는지 확인
          if (!show || Math.abs(tempV.z) > 1) {
            // 이름표를 숨깁니다.
            elem.style.display = 'none';
          } else {
            // 이름표를 보이게 합니다.
            elem.style.display = '';

            // 정규화된 위치값을 CSS 좌표로 바꾸기
            const x = (tempV.x * .5 + .5) * canvas.clientWidth;
            const y = (tempV.y * -.5 + .5) * canvas.clientHeight;

            // 이름표 요소를 해당 좌표로 옮기기
            elem.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
          }
        });

        renderer.render(scene, camera);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    }

    main();




  </script>
</body>

</html>