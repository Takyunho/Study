<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>

<body>

  <canvas id="c"></canvas>
  <div id="info">Description</div>
  <!-- <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.141.0/build/three.module.js",
        "GLTFLoader": "https://unpkg.com/three@0.141.0/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script> -->
  <script type="importmap">{
    "imports": {
      "three": "https://threejs.org/build/three.module.js",
      "three/addons/": "https://threejs.org/examples/jsm/"
    }
  }</script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    function main() {
      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({ canvas });

      // 카메라
      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      const far = 50;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(0, 2, 5);

      // 마우스로 드래그 이동
      const controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 2, 0);
      controls.update();

      const scene = new THREE.Scene();
      scene.background = new THREE.Color('white');


      // 2개의 조명
      function addLight(position) {
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity);
        light.position.set(...position);
        scene.add(light);
        scene.add(light.target);
      }
      addLight([-3, 1, 1]); // 좌측 조명 
      addLight([2, 1, .5]); // 우측 조명

      // 물체 만들기(바디)
      const bodyRadiusTop = .4; // 물체의 탑부분
      const bodyRadiusBottom = .2;  // 물체의 바텀부분 
      const bodyHeight = 2; // 물체 높이
      const bodyRadialSegments = 6; // 물체의 각진 부분 

      const bodyGeometry = new THREE.CylinderGeometry(
        bodyRadiusTop, bodyRadiusBottom, bodyHeight, bodyRadialSegments);

      // 물체 만들기(헤드)
      const headRadius = bodyRadiusTop * 0.8;
      const headLonSegments = 12;
      const headLatSegments = 5;
      const headGeometry = new THREE.SphereGeometry(
        headRadius, headLonSegments, headLatSegments);


      // 라벨 지오메트리 만들기 
      const labelGeometry = new THREE.PlaneGeometry(1, 1);




      // canvas 요소 만들고 ctx에 저장
      const ctx = document.createElement('canvas').getContext('2d');

      // 캔버스로 라벨 만드는 함수(명찰부분)
      // 2D 캔버스를 이용해 명찰을 만드는 함수
      function makeLabelCanvas(baseWidth, size, name) {
        const borderSize = 2;
        const font = `${size}px bold sans-serif`;
        ctx.font = font;
        // 이름의 길이를 예측합니다.
        const textWidth = ctx.measureText(name).width;

        const doubleBorderSize = borderSize * 2;
        const width = baseWidth + doubleBorderSize;
        const height = size + doubleBorderSize;
        ctx.canvas.width = width;
        ctx.canvas.height = height;

        // 캔버스 크기를 바꿨을 때 폰트를 다시 설정해줘야 합니다.
        ctx.font = font;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';

        ctx.fillStyle = 'blue';
        ctx.fillRect(0, 0, width, height);

        // 명찰의 크기에 맞춰 조정하되 늘어나지 않도록 합니다.
        const scaleFactor = Math.min(1, baseWidth / textWidth);
        ctx.translate(width / 2, height / 2);
        ctx.scale(scaleFactor, 1);
        ctx.fillStyle = 'white';
        ctx.fillText(name, 0, 0);

        return ctx.canvas;
      }

      const forceTextureInitialization = function () {
        const material = new THREE.MeshBasicMaterial();
        const geometry = new THREE.PlaneGeometry();
        const scene = new THREE.Scene();
        scene.add(new THREE.Mesh(geometry, material));
        const camera = new THREE.Camera();

        return function forceTextureInitialization(texture) {
          material.map = texture;
          renderer.render(scene, camera);
        };
      }();

      //!!!! geometry들을 이용해 사람을 만드는 함수
      function makePerson(x, labelWidth, size, name, color) {
        const canvas = makeLabelCanvas(labelWidth, size, name);
        const texture = new THREE.CanvasTexture(canvas);
        // 텍스처용 캔버스는 2D이므로 픽셀이 모자랑 경우 대략적으로
        // 필터링하게끔 설정합니다.
        texture.minFilter = THREE.LinearFilter;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        forceTextureInitialization(texture);

        const labelMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide, // 뒤로 돌려도 양쪽이 보이도록 함
          transparent: true,
        });
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color,
          flatShading: true,
        });

        // 오브젝트 3D를 사용하면 객체를 겹칠 수 있다? 
        const root = new THREE.Object3D();
        console.log(root)
        root.position.x = x;

        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        root.add(body);
        body.position.y = bodyHeight / 2;

        // const head = new THREE.Mesh(headGeometry, bodyMaterial);
        // root.add(head);
        // head.position.y = bodyHeight + headRadius * 1.1;

        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        root.add(label);
        label.position.y = bodyHeight * 4 / 5;
        label.position.z = bodyRadiusTop * 1.01;

        // if units are meters then 0.01 here makes size
        // of the label into centimeters.
        const labelBaseScale = 0.01;
        label.scale.x = canvas.width * labelBaseScale;
        label.scale.y = canvas.height * labelBaseScale;

        scene.add(root);
        return root;
      }

      makePerson(-3, 100, 32, '불량', 'purple');
      makePerson(-0, 150, 32, 'Green Machine', 'green');
      makePerson(+3, 150, 32, 'Red Menace', 'red');

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function render() {
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        renderer.render(scene, camera);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    }

    main();

  </script>
</body>

</html>